package org.academic.symbolicx.generation;

import com.microsoft.z3.Expr;
import com.microsoft.z3.FuncDecl;
import com.microsoft.z3.Model;

import sootup.java.core.JavaSootMethod;
import sootup.java.core.types.JavaClassType;

import javax.lang.model.element.Modifier;

import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;

import org.academic.symbolicx.execution.SymbolicState;
import org.academic.symbolicx.util.Pair;
import org.junit.jupiter.api.Test;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import com.palantir.javapoet.*;

/**
 * Generates JUnit test cases from a given Z3 model and symbolic state for a
 * single class under test.
 */
public class TestCaseGenerator {
    private static final Logger logger = LoggerFactory.getLogger(TestCaseGenerator.class);

    String testClassName;
    TypeSpec.Builder classBuilder;
    Class<?> cutType;

    public TestCaseGenerator(JavaClassType classType) throws ClassNotFoundException {
        testClassName = classType.getClassName() + "Test";
        classBuilder = TypeSpec.classBuilder(testClassName)
                .addModifiers(Modifier.PUBLIC);
        cutType = Class.forName(classType.getFullyQualifiedName());
    }

    /**
     * Generates JUnit test cases for the given method based on the given models.
     * 
     * Each model represents a different input for the method, and thus will result
     * in a separate test case.
     * 
     * @param models The models to generate test cases for
     * @param method The method to generate test cases for
     */
    public void generateMethodTestCases(List<Pair<Model, SymbolicState>> results, JavaSootMethod method) {
        logger.info("Generating JUnit test cases...");
        String testMethodName = "test" + capitalizeFirstLetter(method.getName());

        for (int i = 0; i < results.size(); i++) {
            Model model = results.get(i).getFirst();
            // SymbolicState state = results.get(i).getSecond();

            MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder(testMethodName + (i + 1))
                    .addModifiers(Modifier.PUBLIC)
                    .addAnnotation(Test.class)
                    .returns(void.class);

            List<String> parameters = new ArrayList<>();
            for (FuncDecl<?> decl : model.getConstDecls()) {
                String var = decl.getName().toString();
                Expr<?> value = model.getConstInterp(decl);
                methodBuilder.addStatement("$T $L = $L", getJavaType(value), var, value.toString());
                if (var.startsWith("p")) {
                    parameters.add(var);
                }
            }
            // Sort the parameters to ensure they are in the correct order expected by the
            // method
            List<String> sortedParameters = parameters.stream().sorted().toList();

            // TODO: constructor may need arguments as well (deal with <init> method)
            methodBuilder.addStatement("$T cut = new $T()", cutType, cutType);
            methodBuilder.addStatement("cut.$L($L)", method.getName(), String.join(", ", sortedParameters));

            // TODO: add an assert for the path condition (convert Z3 expression to Java)

            classBuilder.addMethod(methodBuilder.build());
        }
    }

    /**
     * Writes the generated JUnit test cases for the current class to a file at the
     * given path.
     * 
     * @param path The path to write the test cases to
     */
    public void writeToFile(Path path) {
        try {
            String packageName = "tests";
            JavaFile javaFile = JavaFile
                    .builder(packageName, classBuilder.build())
                    .addFileComment("Auto-generated by SymbolicX")
                    .build();
            javaFile.writeToPath(path);
            logger.info("JUnit test cases written to src/test/java/" + packageName + "/" + testClassName + ".java");
        } catch (Exception e) {
            logger.error("Failed to generate JUnit test cases: " + e.getMessage());
        }
    }

    /**
     * Get the Java type of the given Z3 expression.
     * 
     * @param value The Z3 expression
     * @return The Java type of the Z3 expression as a string
     */
    private Class<?> getJavaType(Expr<?> value) {
        if (value.isInt())
            return int.class;
        ;
        if (value.isBool())
            return boolean.class;
        if (value.isReal())
            return double.class;
        if (value.isString())
            return String.class;
        // TODO: handle other types
        return Object.class;
    }

    private String capitalizeFirstLetter(String str) {
        if (str == null || str.isEmpty()) {
            return str;
        }
        return str.substring(0, 1).toUpperCase() + str.substring(1);
    }
}